using System;
using System.IO;
using System.Text;

namespace Project_Illumination.Exploits.Helpers
{
    internal class SQLite
    {
        private readonly byte[] _sqlDataTypeSize = {0, 1, 2, 3, 4, 6, 8, 8, 0, 0};
        private readonly ulong _dbEncoding;
        private readonly byte[] _fileBytes;
        private readonly ulong _pageSize;
        private string[] _fieldNames;
        private SqliteMasterEntry[] _masterTableEntries;
        private TableEntry[] _tableEntries;

        public SQLite(string fileName)
        {
            _fileBytes = File.ReadAllBytes(fileName);
            _pageSize = ConvertToULong(16, 2);
            _dbEncoding = ConvertToULong(56, 4);
            ReadMasterTable(100L);
        }

        public string GetValue(int rowNum, int field)
        {
            try
            {
                if (rowNum >= _tableEntries.Length)
                    return null;
                return field >= _tableEntries[rowNum].Content.Length ? null : _tableEntries[rowNum].Content[field];
            }
            catch
            {
                return "";
            }
        }

        public int GetRowCount()
        {
            return _tableEntries.Length;
        }

        private bool ReadTableFromOffset(ulong offset)
        {
            try
            {
                switch (_fileBytes[offset])
                {
                    case 13:
                    {
                        var n = (uint) (ConvertToULong((int) offset + 3, 2) - 1UL);
                        var m = 0;
                        if (_tableEntries != null)
                        {
                            m = _tableEntries.Length;
                            Array.Resize(ref _tableEntries, _tableEntries.Length + (int) n + 1);
                        }
                        else
                        {
                            _tableEntries = new TableEntry[(int) n + 1];
                        }

                        for (uint i = 0; (int) i <= (int) n; ++i)
                        {
                            var o = ConvertToULong((int) offset + 8 + (int) i * 2, 2);
                            if ((long) offset != 100L) o += offset;

                            var endIdx1 = Gvl((int) o);
                            Cvl((int) o, endIdx1);
                            var endIdx2 = Gvl((int) ((long) o + (endIdx1 - (long) o) + 1L));
                            Cvl((int) ((long) o + (endIdx1 - (long) o) + 1L), endIdx2);
                            var num4 = o + (ulong) (endIdx2 - (long) o + 1L);
                            var endIdx3 = Gvl((int) num4);
                            var endIdx4 = endIdx3;
                            var num5 = Cvl((int) num4, endIdx3);
                            RecordHeaderField[] array = null;
                            var num6 = (long) num4 - endIdx3 + 1L;
                            var j = 0;
                            while (num6 < num5)
                            {
                                Array.Resize(ref array, j + 1);
                                var startIdx = endIdx4 + 1;
                                endIdx4 = Gvl(startIdx);
                                array[j].Type = Cvl(startIdx, endIdx4);
                                array[j].Size = array[j].Type <= 9L ? _sqlDataTypeSize[array[j].Type] :
                                    !IsOdd(array[j].Type) ? (array[j].Type - 12L) / 2L : (array[j].Type - 13L) / 2L;
                                num6 = num6 + (endIdx4 - startIdx) + 1L;
                                ++j;
                            }

                            if (array == null) continue;
                            _tableEntries[m + (int) i].Content = new string[array.Length];

                            var num7 = 0;
                            for (var k = 0; k <= array.Length - 1; ++k)
                            {
                                if (array[k].Type > 9L)
                                {
                                    if (!IsOdd(array[k].Type))
                                        _tableEntries[m + (int) i].Content[k] = (long) _dbEncoding switch
                                        {
                                            1L => Encoding.Default.GetString(_fileBytes,
                                                (int) ((long) num4 + num5 + num7), (int) array[k].Size),
                                            2L => Encoding.Unicode.GetString(_fileBytes,
                                                (int) ((long) num4 + num5 + num7), (int) array[k].Size),
                                            3L => Encoding.BigEndianUnicode.GetString(_fileBytes,
                                                (int) ((long) num4 + num5 + num7), (int) array[k].Size),
                                            _ => _tableEntries[m + (int) i].Content[k]
                                        };
                                    else
                                        _tableEntries[m + (int) i].Content[k] = Encoding.Default.GetString(_fileBytes,
                                            (int) ((long) num4 + num5 + num7), (int) array[k].Size);
                                }
                                else
                                {
                                    _tableEntries[m + (int) i].Content[k] = Convert.ToString(
                                        ConvertToULong((int) ((long) num4 + num5 + num7), (int) array[k].Size));
                                }

                                num7 += (int) array[k].Size;
                            }
                        }

                        break;
                    }
                    case 5:
                    {
                        var n = (uint) (ConvertToULong((int) ((long) offset + 3L), 2) - 1UL);
                        for (uint i = 0; (int) i <= (int) n; ++i)
                        {
                            var m = (uint) ConvertToULong((int) offset + 12 + (int) i * 2, 2);
                            ReadTableFromOffset((ConvertToULong((int) ((long) offset + m), 4) - 1UL) * _pageSize);
                        }

                        ReadTableFromOffset((ConvertToULong((int) ((long) offset + 8L), 4) - 1UL) * _pageSize);
                        break;
                    }
                }

                return true;
            }
            catch
            {
                return false;
            }
        }

        private void ReadMasterTable(long offset)
        {
            try
            {
                switch (_fileBytes[offset])
                {
                    case 5:
                        var n = (uint) (ConvertToULong((int) offset + 3, 2) - 1UL);
                        for (var i = 0; i <= (int) n; ++i)
                        {
                            var m = (uint) ConvertToULong((int) offset + 12 + i * 2, 2);
                            if (offset == 100L)
                                ReadMasterTable(((long) ConvertToULong((int) m, 4) - 1L) * (long) _pageSize);
                            else
                                ReadMasterTable(((long) ConvertToULong((int) (offset + m), 4) - 1L) * (long) _pageSize);
                        }

                        ReadMasterTable(((long) ConvertToULong((int) offset + 8, 4) - 1L) * (long) _pageSize);
                        break;
                    case 13:
                        var o = ConvertToULong((int) offset + 3, 2) - 1UL;
                        var num4 = 0;
                        if (_masterTableEntries != null)
                        {
                            num4 = _masterTableEntries.Length;
                            Array.Resize(ref _masterTableEntries, _masterTableEntries.Length + (int) o + 1);
                        }
                        else
                        {
                            _masterTableEntries = new SqliteMasterEntry[checked((ulong) unchecked((long) o + 1L))];
                        }

                        for (ulong i = 0; i <= o; ++i)
                        {
                            var m = ConvertToULong((int) offset + 8 + (int) i * 2, 2);
                            if (offset != 100L)
                                m += (ulong) offset;
                            var endIdx1 = Gvl((int) m);
                            Cvl((int) m, endIdx1);
                            var endIdx2 = Gvl((int) ((long) m + (endIdx1 - (long) m) + 1L));
                            Cvl((int) ((long) m + (endIdx1 - (long) m) + 1L), endIdx2);
                            var num5 = m + (ulong) (endIdx2 - (long) m + 1L);
                            var endIdx3 = Gvl((int) num5);
                            var endIdx4 = endIdx3;
                            var num6 = Cvl((int) num5, endIdx3);
                            var numArray = new long[5];
                            for (var j = 0; j <= 4; ++j)
                            {
                                var startIdx = endIdx4 + 1;
                                endIdx4 = Gvl(startIdx);
                                numArray[j] = Cvl(startIdx, endIdx4);
                                numArray[j] = numArray[j] <= 9L ? _sqlDataTypeSize[numArray[j]] :
                                    !IsOdd(numArray[j]) ? (numArray[j] - 12L) / 2L : (numArray[j] - 13L) / 2L;
                            }

                            if ((long) _dbEncoding == 1L || (long) _dbEncoding == 2L)

                                if ((long) _dbEncoding == 1L)
                                    _masterTableEntries[num4 + (int) i].ItemName =
                                        Encoding.Default.GetString(_fileBytes, (int) ((long) num5 + num6 + numArray[0]),
                                            (int) numArray[1]);
                                else if ((long) _dbEncoding == 2L)
                                    _masterTableEntries[num4 + (int) i].ItemName =
                                        Encoding.Unicode.GetString(_fileBytes, (int) ((long) num5 + num6 + numArray[0]),
                                            (int) numArray[1]);
                                else if ((long) _dbEncoding == 3L)
                                    _masterTableEntries[num4 + (int) i].ItemName =
                                        Encoding.BigEndianUnicode.GetString(_fileBytes,
                                            (int) ((long) num5 + num6 + numArray[0]), (int) numArray[1]);
                            _masterTableEntries[num4 + (int) i].RootNum = (long) ConvertToULong(
                                (int) ((long) num5 + num6 + numArray[0] + numArray[1] + numArray[2]),
                                (int) numArray[3]);
                            if ((long) _dbEncoding == 1L)
                                _masterTableEntries[num4 + (int) i].SqlStatement =
                                    Encoding.Default.GetString(_fileBytes,
                                        (int) ((long) num5 + num6 + numArray[0] + numArray[1] + numArray[2] +
                                               numArray[3]), (int) numArray[4]);
                            else if ((long) _dbEncoding == 2L)
                                _masterTableEntries[num4 + (int) i].SqlStatement =
                                    Encoding.Unicode.GetString(_fileBytes,
                                        (int) ((long) num5 + num6 + numArray[0] + numArray[1] + numArray[2] +
                                               numArray[3]), (int) numArray[4]);
                            else if ((long) _dbEncoding == 3L)
                                _masterTableEntries[num4 + (int) i].SqlStatement =
                                    Encoding.BigEndianUnicode.GetString(_fileBytes,
                                        (int) ((long) num5 + num6 + numArray[0] + numArray[1] + numArray[2] +
                                               numArray[3]), (int) numArray[4]);
                        }

                        break;
                }
            }
            catch (Exception ex)
            {
                if (Program._DEBUG) Console.WriteLine(ex.Message);
            }
        }

        public bool ReadTable(string tableName)
        {
            try
            {
                var i = -1;
                for (var j = 0; j <= _masterTableEntries.Length; ++j)
                {
                    if (string.Compare(_masterTableEntries[j].ItemName.ToLower(), tableName.ToLower(),
                        StringComparison.Ordinal) != 0) continue;
                    i = j;
                    break;
                }

                if (i == -1) return false;

                var strArray = _masterTableEntries[i].SqlStatement
                    .Substring(_masterTableEntries[i].SqlStatement.IndexOf("(", StringComparison.Ordinal) + 1)
                    .Split(',');
                for (var j = 0; j <= strArray.Length - 1; ++j)
                {
                    strArray[j] = strArray[j].TrimStart();
                    var length = strArray[j].IndexOf(' ');

                    if (length > 0) strArray[j] = strArray[j].Substring(0, length);
                    if (strArray[j].IndexOf("UNIQUE", StringComparison.Ordinal) == 0) continue;

                    Array.Resize(ref _fieldNames, j + 1);
                    _fieldNames[j] = strArray[j];
                }

                return ReadTableFromOffset((ulong) (_masterTableEntries[i].RootNum - 1L) * _pageSize);
            }
            catch
            {
                return false;
            }
        }

        private ulong ConvertToULong(int startIndex, int size)
        {
            try
            {
                if ((size > 8) | (size == 0))
                    return 0;
                ulong num = 0;
                for (var i = 0; i <= size - 1; ++i)
                    num = (num << 8) | _fileBytes[startIndex + i];
                return num;
            }
            catch
            {
                return 0;
            }
        }

        private int Gvl(int startIdx)
        {
            try
            {
                if (startIdx > _fileBytes.Length)
                    return 0;
                for (var i = startIdx; i <= startIdx + 8; ++i)
                {
                    if (i > _fileBytes.Length - 1)
                        return 0;
                    if ((_fileBytes[i] & 128) != 128)
                        return i;
                }

                return startIdx + 8;
            }
            catch
            {
                return 0;
            }
        }

        private long Cvl(int startIdx, int endIdx)
        {
            try
            {
                ++endIdx;

                var numArray = new byte[8];
                var n = endIdx - startIdx;
                var flag = false;

                if ((n == 0) | (n > 9)) return 0;
                if (n == 1)
                {
                    numArray[0] = (byte) (_fileBytes[startIdx] & (uint) sbyte.MaxValue);
                    return BitConverter.ToInt64(numArray, 0);
                }

                if (n == 9) flag = true;

                int m = 1, o = 7, i = 0;
                if (flag)
                {
                    numArray[0] = _fileBytes[endIdx - 1];
                    --endIdx;
                    i = 1;
                }

                var j = endIdx - 1;
                while (j >= startIdx)
                {
                    if (j - 1 >= startIdx)
                    {
                        numArray[i] = (byte) (((_fileBytes[j] >> (m - 1)) & (byte.MaxValue >> m)) |
                                              (_fileBytes[j - 1] << o));
                        ++m;
                        ++i;
                        --o;
                    }
                    else if (!flag)
                    {
                        numArray[i] = (byte) ((_fileBytes[j] >> (m - 1)) & (byte.MaxValue >> m));
                    }

                    j += -1;
                }

                return BitConverter.ToInt64(numArray, 0);
            }
            catch
            {
                return 0;
            }
        }

        private static bool IsOdd(long value)
        {
            return (value & 1L) == 1L;
        }

        private struct RecordHeaderField
        {
            public long Size;
            public long Type;
        }

        private struct TableEntry
        {
            public string[] Content;
        }

        private struct SqliteMasterEntry
        {
            public string ItemName;
            public long RootNum;
            public string SqlStatement;
        }

        public static SQLite ReadTable(string database, string table)
        {
            if (!File.Exists(database)) return null;

            var newPath = Path.GetTempFileName() + ".dat";
            File.Copy(database, newPath);

            var sql = new SQLite(newPath);
            sql.ReadTable(table);

            File.Delete(newPath);

            return sql.GetRowCount() == 65536 ? null : sql;
        }
    }
}